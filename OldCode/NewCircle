package de.tum.cit.fop.maze.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import de.tum.cit.fop.maze.entity.Enemy;
import de.tum.cit.fop.maze.entity.Player;
import de.tum.cit.fop.maze.entity.World;


public class Staff {
    private TextureRegion staffTexture;
    private float swordX;
    private float swordY;
    private static final float FRAME_DURATION = 0.1f;
    private float swordRotation;
    private float swordPivotX;
    private float swordPivotY;
    private float damage;
    private float range;
    private float scale = 0.33f;
    private boolean isAttacking = false;
    private boolean isReturning = false;
    private float smoothFactor = 0.1f;
    private float stateTime; // Distance from the player
    private Vector2 mousePosition = new Vector2(); // Mouse position in world coordinates
    private Vector2 direction = new Vector2(); // Distance of the sword from the player
    private Texture spellsprite;
    private Animation<TextureRegion> spell;
    private TextureRegion currentframe;
    private Vector2 attackPosition = new Vector2();
    private String name;
    private float attackspeed;
    private float timeSinceLastAttack;
    private String description;
    private final Array<SpellInstance> activeSpells = new Array<>();
    private final Array<Projectile> activeProjectiles = new Array<>();
    private Sound sound;
    private Array<Enemy> enemies = new Array<>();
    private int numEnemies;
    private World world;
    private boolean isProjectile;
    private boolean isHoming;
    private boolean found;
    private boolean isEquiped;
    private int price;

    // Constructor: Loads texture and initializes variables
    public Staff(String name, String TexturePath, String SpellSpriteSheet, Float damage, Float range, int row, Float attackspeed, String description, String pathforsound,Boolean isProjectile,int spritesize,boolean isHoming,boolean found,int price) {
        this.damage = damage;
        this.range = range;
        this.name = name;
        this.isHoming=isHoming;
        this.isProjectile = isProjectile;
        this.attackspeed = attackspeed;
        this.description = description;
        this.found=found;
        this.price=price;
        timeSinceLastAttack = attackspeed;
        numEnemies = enemies.size;
        sound = Gdx.audio.newSound(Gdx.files.internal(pathforsound)); // Load texture and create texture region
        this.staffTexture = new TextureRegion(new Texture(TexturePath));
        spellsprite = new Texture(SpellSpriteSheet);
        TextureRegion[][] frames = TextureRegion.split(spellsprite, spritesize, spritesize);
        spell = new Animation<>(FRAME_DURATION, frames[row]);
        setPivot(staffTexture.getRegionWidth(), staffTexture.getRegionHeight());
        // Initialize rotation
        this.swordRotation = 0;
        currentframe = spell.getKeyFrame(0);
    }

    // Render method: Draws the sword at the correct position and rotation
    public void render(Batch batch) {
        batch.draw(
                staffTexture,
                swordX, swordY, // Sword position
                swordPivotX, swordPivotY,
                staffTexture.getRegionWidth() * scale, staffTexture.getRegionHeight() * scale, // Sword size
                1f, 1f, // Scaling
                swordRotation // Rotation in degrees
        );
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public void setWorld(World world) {
        this.world = world;
    }

    public void setEnemies(Array<Enemy> enemies) {
        this.enemies = enemies;
    }

    public void updatePosition(float playerX, float playerY, Camera camera) {
        mousePosition.set(Gdx.input.getX(), Gdx.input.getY());
        Vector3 worldMouse = camera.unproject(new Vector3(mousePosition.x, mousePosition.y, 0));
        mousePosition.set(worldMouse.x, worldMouse.y);

        direction.set(mousePosition.x - playerX, mousePosition.y - playerY).nor();
        swordRotation = direction.angleDeg() - 90f;

        swordX = lerp(swordX, playerX - swordPivotX + direction.x * staffTexture.getRegionHeight() * scale / 2, smoothFactor);
        swordY = lerp(swordY, playerY - swordPivotY + direction.y * staffTexture.getRegionHeight() * scale / 2, smoothFactor);
    }

    private float lerp(float current, float target, float factor) {
        return current + (target - current) * factor;
    }

    public void update(float delta,Player player) {
        timeSinceLastAttack += delta;

        // Update all active spells
        if(!isProjectile) {
            if(mousePosition.dst(player.getPosition())<range) {
                for (int i = activeSpells.size - 1; i >= 0; i--) {
                    SpellInstance spell = activeSpells.get(i);
                    spell.update(delta);

                    // Check for collisions with enemies
                    for (Enemy enemy : enemies) {
                        if (!spell.hasCollided() && spell.isEnemyWithinBounds(enemy.getPosition())) {
                            enemy.takeDamage(damage);
                            spell.setCollided(true); // Mark the spell as collided
                            Gdx.app.log("Staff", "Enemy hit: " + enemy);
                            break; // Exit the loop once a collision is detected
                        }
                    }
                }
            }
        } else {
            for (int i = activeProjectiles.size - 1; i >= 0; i--) {
                Projectile projectile = activeProjectiles.get(i);
                projectile.update(delta);

                // Check collision with enemies
                for (Enemy enemy : enemies) {
                    if (!projectile.hasCollided() && projectile.isEnemyWithinBounds(enemy.getHitbox(), enemy.isDead())) {
                        enemy.takeDamage(damage);
                        projectile.setCollided(true);
                        break;
                    }
                }

                // Check collision with the world
                Rectangle hitbox = projectile.getHitbox();
                if (projectile.hasCollided() ||
                        world.isCollidable(hitbox.x, hitbox.y) ||
                        world.isCollidable(hitbox.x + hitbox.width, hitbox.y) ||
                        world.isCollidable(hitbox.x, hitbox.y + hitbox.height) ||
                        world.isCollidable(hitbox.x + hitbox.width, hitbox.y + hitbox.height)) {
                    activeProjectiles.removeIndex(i);
                }
            }
        }



    }


    // Attack method: Engages sword rotation animation
    public void attack(Batch batch, float delta,Player player) {
        // Render all active spells
        if (!isProjectile) {
            if(mousePosition.dst(player.getPosition())<range) {
                for (SpellInstance spell : activeSpells) {
                    spell.render(batch);
                }

            }
        }else{
            for(Projectile projectile : activeProjectiles){
                projectile.render(batch);
            }
        }

        // Check for collisions and update spells
        update(delta,player);

        // Render the staff itself
        batch.draw(
                staffTexture,
                swordX, swordY,
                swordPivotX, swordPivotY,
                staffTexture.getRegionWidth() * scale,
                staffTexture.getRegionHeight() * scale,
                1f, 1f,
                swordRotation
        );
    }
    public boolean withinrange(Player player){
        return mousePosition.dst(player.getPosition())<range;
    }

    public void setPivot(float swordWidth, float swordHeight) {
        // Set the pivot point at the bottom-center of the sword sprite
        swordPivotX = swordWidth * scale / 2f;
        swordPivotY = 0f;
    }

    public boolean canAttack() {
        boolean ready = timeSinceLastAttack >= attackspeed;
        Gdx.app.log("Staff", "Can attack: " + ready + " (timeSinceLastAttack: " + timeSinceLastAttack + ")");
        return ready;
    }

    // Start the attack animation (can be triggered by the button press)
    public void startAttack(Player player) {
        if (canAttack()) {
            isAttacking = true;
            sound.play();
            timeSinceLastAttack = 0f;

            if (!isProjectile) {
                if(mousePosition.dst(player.getPosition())<range) {
                    Gdx.app.log("Staff", "Player position: " + player.getPosition() + ", Mouse position: " + mousePosition + ", Distance: " + player.getPosition().dst(mousePosition));
                    activeSpells.add(new SpellInstance(spell, mousePosition, scale));
                }
            } else {




                // Attack start position
                Vector2 attackStartPosition = new Vector2(player.getHitbox().x-(player.getHitbox().width/2), player.getHitbox().y-(player.getHitbox().height/2));

                // Add the projectile
                activeProjectiles.add(new Projectile(
                        spell,
                        attackStartPosition,
                        mousePosition,
                        0.5f,
                        isHoming,
                        enemies,world
                ));
            }
            Gdx.app.log("Staff", "Started attack with projectile at position: " + mousePosition);
        }
    }

    public boolean isEquiped() {
        return isEquiped;
    }

    public void setEquiped(boolean equiped) {
        isEquiped = equiped;
    }

    public String getName() {
        return name;
    }

    public boolean isFound() {
        return found;
    }

    public void setFound(boolean found) {
        this.found = found;
    }

    public Animation<TextureRegion> getSpell() {
        return spell;
    }

    public TextureRegion getStaffTexture() {
        return staffTexture;
    }

    public float getAttackspeed() {
        return attackspeed;
    }

    public float getTimeSinceLastAttack() {
        return timeSinceLastAttack;
    }

    public String getDescription() {
        return description;
    }

    public float getDamage() {
        return damage;
    }

    public void setDamage(float damage) {
        this.damage = damage;
    }

    public float getRange() {
        return range;
    }

    public void setRange(float range) {
        this.range = range;
    }

    public boolean isProjectile() {
        return isProjectile;
    }

    public void setProjectile(boolean projectile) {
        isProjectile = projectile;
    }

    public boolean isHoming() {
        return isHoming;
    }

    public void setHoming(boolean homing) {
        isHoming = homing;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAttackspeed(float attackspeed) {
        this.attackspeed = attackspeed;
    }
}